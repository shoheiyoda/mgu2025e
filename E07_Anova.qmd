---
title: "分散分析"
---

```{r setup}
#| include: false
library(tidyverse)
library(ggthemes)
```

## データ・変数
### データ
[東大社研・若年パネル調査の非制限公開疑似データ](https://csrda.iss.u-tokyo.ac.jp/infrastructure/urd/jlps/)を用いる。

```{r}
library(tidyverse)
FN_Data2Load <- "data/u001.csv"
DF_org <- read_csv(FN_Data2Load)
```

以下では次の問いに答えることを目的とする。

> Q: 学歴によって個人収入に違いはあるのか？

なお、今回は分析対象を**25-34歳の男性**に限定する。

### 変数
- 回答者の性別: `sex`
- 回答者の生年月: `ybirth`, `mbirth`
- 回答者の学歴: `ZQ23A`
  - 以下の3カテゴリにリコード
    - 中学・高校(`JHS/HS`)
    - 専門・短大(`VS/JC`)
    - 大学・大学院(`Univ`)
    
- 回答者の個人収入: `ZQ47A`
  - 回答選択肢の中央値にリコード
  - 例：「100万円くらい（75〜150万円未満）」 -> 100万円

#### 「調査時年齢」の作成
まず、分析対象を25-34歳の男性に限定するために、「調査時点の満年齢」を新規変数として作成する必要がある。調査票で測定されているのは回答者の生年月（`ybirth`, `mbirth`）であるからである。同じ生年（`ybirth`）でも誕生月（`mbirth`）が調査月よりも前か後かで調査時点の満年齢が異なることに注意されたい。例えば以下のようなコードの書き方が挙げられる。

```{r}
SurveyYear  <- 2007
MonthSurvey <- 1

DF_temp_1 <-
  DF_org |> 
  select(sex, ybirth, mbirth, ZQ23A, ZQ47A) |> 
  mutate(CAgeSvy = if_else(
          (MonthSurvey - mbirth) < 0,  # 調査月より誕生月が遅い場合
          SurveyYear - ybirth - 1,     # 誕生日がまだ来ていないので1歳引く
          SurveyYear - ybirth          # 誕生日がすでに来ているのでそのまま
        )
  )

DF_temp_1 |>
  select(ybirth, mbirth, CAgeSvy) |> 
  head()
```

また、{tidyverse}には{lubridate}という時間処理を行うためのパッケージも含まれており、このパッケージ内の関数群を使うと、時間に関する処理を効率よく行うことができる（ことも多い）。今回の例（調査時点の満年齢の計算）の場合は{lubridate}を使わずとも比較的簡単に変数を作成できたが、参考として{lubridate}を用いた場合のコード例を示しておく。

```{r}
#| code-fold: true
#| eval: false

# 調査日を定義
SurveyDate <- ymd("2007-01-01")

print(SurveyDate)

# 満年齢を計算するコード
DF_temp_1 <-
  DF_org |> 
  select(sex, ybirth, mbirth, ZQ23A, ZQ47A) |> 
  mutate(BthDate = make_date(ybirth, mbirth, 1),                 # 生年月をDate型に変換
         CAgeSvy = as.period(interval(BthDate, SurveyDate))$year # 調査日時点の満年齢を計算
  ) |> 
  select(-BthDate)

DF_temp_1 |>
  select(ybirth, mbirth, CAgeSvy) |> 
  head()
```

#### 「学歴」と「個人収入」の準備
つづいて、分散分析において独立変数と従属変数となる、「学歴」と「個人収入」を準備しよう。学歴変数のリコードについては「第4回　母平均の差の検定」の際にも同様の作業を行ったのでそちらを参照のこと。個人収入の元変数`ZQ47A`の度数分布表を確認しておくと、

```{r}
DF_temp_1 |> 
  count(ZQ47A)
```

不詳コードが`99`であることが確認できる（コードブックも参照のこと）。これに注意して、新規変数`Income`を作成しておく。なおオープンエンドのカテゴリである「13.　2500万円以上」にどのような数値を割り当てるかは難しいところではあるが、今回はあくまで分散分析の練習が目的であるため、便宜的に「2500万円」を割り当てることにする。

```{r}
DF_temp_2 <-
  DF_temp_1 |> 
  mutate(Edu3Grp = case_match(ZQ23A,
                              c(1,2) ~ "JHS/HS",
                              c(3,4) ~ "VS/JC",
                              c(5,6) ~ "Univ",
                              TRUE   ~ NA_character_) |> 
                   fct_relevel("JHS/HS", "VS/JC", "Univ")
         ) |> 
  mutate(Income = case_match(ZQ47A,
                             1 ~    0,
                             2 ~   12.5,
                             3 ~   50,
                             4 ~  100,
                             5 ~  200,
                             6 ~  300,
                             7 ~  400,
                             8 ~  500,
                             9 ~  700,
                            10 ~ 1000,
                            11 ~ 1500,
                            12 ~ 2000,
                            13 ~ 2500,
                            c(14,99) ~ NA_real_)
  )

# 新規変数Incomeが問題なく定義できているかチェック
DF_temp_2 |> 
  count(ZQ47A, Income)
```

#### 集計対象の限定と使用変数の指定
データ前処理の最後の段階として、集計対象の限定（25-34歳の男性回答者）をした上で、分散分析に使用する変数（学歴と個人収入）だけをデータフレームの中に残す。

```{r}
DF <-
  DF_temp_2 |> 
  filter(sex == 1 & CAgeSvy %in% c(25:34)) |> 
  select(Edu3Grp, Income) |> 
  drop_na()
```

## 分析
### グループ別に記述統計量を算出
まずは学歴グループ別に個人収入の記述統計量を算出しておく。ここでは

 - 平均値
 - 標準偏差
 - 客体数

を出力しておこう。

```{r}
DF |> 
  group_by(Edu3Grp) |> 
  reframe(Mean = mean(Income),
          SD   = sd(Income),
          n    = n())

```

少なくとも平均値の点推定量を見る限りでは、大学卒の個人年収が最も高く、中学・高校卒、専門・短大卒とつづく。個人収入の分布を比較するために、学歴別に箱ひげ図を描画してみよう。

```{r}
#| code-fold: true

DF |> 
  ggplot(aes(x = Edu3Grp,
             y = Income)) +
  geom_boxplot() +
  theme_few() +
  theme(strip.text   = element_text(size = rel(1.5)),
        axis.text.x  = element_text(size = rel(1.5)),
        axis.text.y  = element_text(size = rel(1.5)),
        axis.title.x = element_text(size = rel(1.5)),
        axis.title.y = element_text(size = rel(1.3)))
```

### 分散分析
分散分析を実行するには`anova()`コマンドを用いる。

```{r}
DF |> 
  with(anova(lm(Income ~ Edu3Grp)))
```

`lm`の後にはモデル式を「従属変数 ~ 独立変数」の形式で指定する。`anova()`コマンドは分散分析表を返し、上記の例では「全ての学歴の平均収入が等しい」という帰無仮説は棄却されていることがわかる。

### 多重比較
`anova()`によって帰無仮説（「全ての平均値が等しい」）が棄却された場合、どのカテゴリ間で平均値に差があるのかを確認するために多重比較を行う（ただし、別の考え方として、初めから多重比較のみを行うべきという立場も存在する）。多重比較の方法は数多く存在するが、以下では代表的なものとして、Tukey法、Holm法、bonferroni法を紹介する。

::: {.panel-tabset}
#### Tukey法
```{r}
DF |> 
  with(aov(Income ~ Edu3Grp)) |> 
  TukeyHSD()
```

#### Holm法
```{r}
DF |> 
  with(pairwise.t.test(Income, Edu3Grp))
```

#### bonferroni法
```{r}
DF |> 
  with(pairwise.t.test(Income, Edu3Grp, p.adjust.method = "bonferroni"))
```
:::

今回の例の場合、有意水準を5%に設定すると、個人収入の平均値に統計的な有意差が確認されるのは「大学卒」と「専門・短大卒」との間であることがわかる。

## 多元配置分散分析へ
ここまで、独立変数が1つの場合（今回の例では学歴）の分散分析について解説した。次回は独立変数に性別を加えて、独立変数が2つ以上の場合の分散分析、すなわち多元配置分散分析について解説する。以下ではそのために用いるデータを保存しておこう。

```{r}
  DF_temp_2 |> 
  filter(CAgeSvy %in% c(25:34)) |> 
  select(sex, Edu3Grp, Income) |> 
  drop_na() |> 
  saveRDS(file = "data/Anova_SexEduIncome.rds")
```